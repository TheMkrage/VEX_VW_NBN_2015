#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLight,      sensorReflection)
#pragma config(Sensor, in2,    midLight,       sensorReflection)
#pragma config(Sensor, in3,    rightLight,     sensorReflection)
#pragma config(Sensor, in4,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEn,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEn,         sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_7,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_8,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightFront,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rightBack,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           rightSlide,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftSlide,     tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           arm,           tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port8,           leftIntake,    tmotorVex393_MC29, openLoop, encoderPort, I2C_8)
#pragma config(Motor,  port9,           rightIntake,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          elevator,      tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MM_PER_REV 295.16
#define ROBOT_WIDTH_MM 310.0
#define ROBOT_LENGTH_MM 530.0
#define ROBOT_WHEEL_DIAMETER_MM 94.0
#define ROBOT_DEG_PER_ROTATION 57.6

// Debugging Vars
bool printAngle = false;
bool printEncodersMM = false;
bool printEncodersRot = false;


// SOME UTIL METHODS
// returns true if input is in range of goal and threshold
bool isInRangeOf(float input, float goal, float threshold) {
	return input < goal + threshold && input > goal - threshold;
}

// Subsystems
#include "Drive.c"
#include "Arm.c"
#include "Shooter.c"

task main()
{
	startTask(driveTracker);
	startTask(driveNavigator);
	startTask(armNavigator);

	//Stack 1 Red Starting Tile Stack
	setShooter(127);
	motor[elevator] = 127;
	wait1Msec(220);
	addToAngle(-26);
	waitForDrive(750);
	setShooter(-127);
	motor[elevator] = -127;
	moveForwardMM(1200);
	waitForDrive();
	setShooter(0);
	motor[elevator] = 0;
	moveArmTo(630);
	addToAngle(88);
	waitForDrive();
	moveForwardMM(-1300);
	waitForDrive();
	shoot(100);
	moveArmTo(0);
	moveForwardMM(100);
	waitForDrive();

	//Stack 2
	addToAngle(60);
	waitForDrive();
	intake();
	moveForwardMM(500);
	waitForDrive();
	wait1Msec(250);
	moveArmTo(630);
	neutral();
	addToAngle(-60);
	waitForDrive();
	moveForwardMM(-500);
	waitForDrive();
	shoot(90);

	// Stack 3 Blue Wall Stack
	moveArmTo(0);
	intake();
	addToAngle(-11);
	waitForDrive(1000);
	moveForwardMM(450);
	addToAngle(115);
	waitForDrive();
	waitForArm(1000);
	moveForwardMMSlow(175);
	waitForDrive();
	wait1Msec(250);
	moveForwardMM(-300);
	waitForDrive();
	moveArmTo(350);
	neutral();
	addToAngle(78);
	waitForDrive();
	moveForwardMM(300);
	shoot(90);

	// Stack 4 Blue Pole Stack
	moveArmTo(0);
	intake();
	addToAngle(85);
	waitForDrive();
	waitForArm(1000);
	moveForwardMM(550);
	waitForDrive();
	moveArmTo(350);
	neutral();
	addToAngle(-117);
	waitForDrive();
	shoot(105);

	// Stack 5
	moveArmTo(0);
	intake();
	addToAngle(95);
	waitForDrive();
	wait1Msec(250);
	moveForwardMM(1000);
	waitForDrive();
	neutral();
	moveArmTo(330);
	addToAngle(35);
	waitForDrive();
	moveForwardMM(500);
	waitForDrive();
	shoot(100);

	// Stack 6 center wall stack
	addToAngle(-20);
	waitForDrive(1000);
	moveArmTo(0);
	moveForwardMM(-420);
	waitForDrive();
	intake();
	addToAngle(-79);
	waitForDrive();
	moveForwardMMSlow(175);
	moveForwardMM(-300);
	waitForDrive();
	moveArmTo(350);
	neutral();
	addToAngle(75);
	waitForDrive();
	moveForwardMM(350);
	waitForDrive();
	shoot(90);

	//Stack 7 Red Pole Stack
	moveArmTo(0);
	intake();
	addToAngle(90);
	waitForDrive();
	waitForArm(1000);
	moveForwardMM(600);
	waitForDrive();
	neutral();
	moveArmTo(350);
	addToAngle(-125);
	waitForDrive();
	waitForArm(500);
	moveForwardMM(300);
	shoot(90);

	// Stack 8
	moveArmTo(0);
	intake();
	addToAngle(110);
	waitForDrive();
	moveForwardMM(900);
	waitForDrive();
	moveArmTo(620);
	neutral();
	addToAngle(50);
	waitForDrive();
	moveForwardMM(-300);
	waitForDrive();
	shoot(100);

	// Stack 9 Blue Starting Tile Stack
	moveArmTo(0);
	intake();
	addToAngle(22);
	waitForDrive(2000);
	moveForwardMM(1100);
	waitForDrive();
	moveArmTo(650);
	neutral();
	moveForwardMM(-1100);
	waitForDrive();
	addToAngle(-22);
	waitForDrive();
	shoot(100);

	// Stack 10 Red wall Stack
	moveArmTo(0);
	intake();
	addToAngle(-91);
	waitForDrive();
	moveForwardMM(-100);
	waitForDrive();
	moveForwardMM(400);
	waitForDrive();
	moveForwardMM(-400);
	waitForDrive();
	neutral();
	moveArmTo(350);
	addToAngle(-140);
	waitForDrive();
	shoot(90);


	// Debug Loop
	while(true)
	{
		wait1Msec(250);
	}
}
